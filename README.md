# Backup-Service


### Пример логики работы

Выполняем следующие действия:

1. Имеем в **Repository** три объекта `File A`, `File B`, `Folder C`.
2. Создаём **Backup Task**, добавляем в неё три **Backup Object**, соответсвующие объектам находящимся в репозитории.
3. Запускаем выполнение **Backup Task**, получаем **Restore Point**, он записывается в репозиторий, в соответствующей директории появляются **Storage** `File A(1)`, `File B(1)`, `Folder C(1)`.
4. Запускаем выполнение ещё раз, получаем **Storage** с версиями `(2)`.
5. Удаляем из **Backup Task** `File B`, запускаем выполнение ещё раз, получаем третий **Restore Point**, ему будут соответствовать два **Storage** - `File A(3)`, `Folder C(3)`.

### Создание резервных копий

Под созданием резервной копии данных, подразумевается создание копии данных в другом месте. Система поддерживает расширяемость в вопросе выбора **Storage Algorithm**, используемых для хранения резервных копий (должна иметь возможность добавить новый алгоритм безболезненно, помним про OCP). 

В данной лабораторной требуется реализовать два **Storage Algorithm**:

1. **Split Storage** – алгоритм раздельного хранения, для каждого **Backup Object** в **Restore Point** создаётся отдельный **Storage** - архив, в котором лежат данные объекта.
2. **Single Storage** – алгоритм общего хранения, для всех **Backup Object** в **Restore Point** создаётся один общий **Storage** - архив, в котором лежат данные каждого объекта.

**Storage Algorithm** не должен нести ответственность за реализацию архивации. 

### Хранение копий

Резервные копии могут сохранятся как на локальной файловой системе, так и в ОЗУ.

В тестах стоит реализованно хранение в памяти (**InMemoryRepository**), так как при запуске тестов на настоящей файловой системе будет генерироваться много мусорных данных, а так же системы CI не дружат с запросами к файловой системе во время автоматического выполнения тестов.

Структура:

- Корневая директория
    - Директории различных **Backup Task**
        - Директории различных **Restore Point**
            - Файлы **Storage**

### Создание Restore Point

**Backup Task** отвечает за создание новых точек восстановления, выступает фасадом, инкапсулируя логику выполнения этой операции. 

При создании **Backup Task** есть возможность указать её название, **Repository** для хранения **Backup** (его данных), **Storage Algorithm**.

**Backup Task** поддерживает операции добавления и удаления отслеживаемых ей **Backup Object**.

Результатом выполнения **Backup Task** является создание **Restore Point** и соответствующих ей **Storage** в выбранном **Repository**.

### Тест кейсы

1. Тест 1
    1. Создаём **Backup Task**, использующую **Split Storage**
    2. Добавляем в **Backup Task** два **Backup Object**
    3. Запускаем выполнение **Backup Task**
    4. Удаляем из **Backup Task** один **Backup Object**
    5. Запускаем выполнение **Backup Task**
    6. Проверяем то, что было создано две **Restore Point** и два **Storage**
2. Тест 2 (лучше оформить в виде консольного приложения, так как нормально проверить можно только на настоящей файловой системе)
    1. Создаём **Backup Task**, использующую **FileSystemRepository** и **Single Storage**
    2. Добавляем в **Backup Task** два **Backup Object**
    3. Запускаем выполнение **Backup Task**
    4. Проверяем то, что директории и файлы были созданы
### Сохранение и загрузка данных

Система должна поддерживать загрузку своего состояния после перезапуска программы. Это может быть реализовано за счёт сохранения данных о настройках **Backup Task** в конфигурационный файл, лежащий в корневой директории. После загрузки ожидается, что в приложение загрузится информация о существующих **Backup Task**, добавленных в них **Backup Object**, созданных **Restore Point** и остальная информация.

### Алгоритмы очистки Restore Point

Помимо создания, нужно контролировать количество созданных **Restore Point**. Чтобы не допускать накопления большого количества старых и не актуальных **Restore Point**, требуется реализовать механизмы их очистки, они должны контролировать, что набор существующих **Restore Point** соответсвует заданному лимиту.

В рамках данной лабораторной необходимо реализовать следующие виды лимитов:

1. По количеству **Restore Point** – храним коллекцию из последних **N** элементов, очищаем остальные.
2. По дате – ограничивает промежуток времени на котором хранятся **Restore Point**, элементы старее данного промежутка - очищаются.
3. Гибридный лимит – пользователь может указывать как комбинировать лимиты: удалять **Restore Point** если он подходит под все требования/хотя бы под одно.

Например пользователь выбирает гибрид лимитов “по количеству” и “по дате”. Под критерии первого лимита подходят точки: `P4`, `P5`. Под критерии второго - `P4`. При гибриде “под все” будет очищена точка `P4`, при гибриде “хотя бы под одно” будут очищены точки `P4`, `P5`.

Ситуация, когда для соответствия лимиту, должны быть удалены все точки - должна обрабатываться.

### Merge

**Merge** работает по правилам:

- Если в старой точке есть объект и в новой точке есть объект - нужно оставить новый, а старый можно удалять
- Если в старой точке есть объект, а в новой его нет - нужно перенести его в новую точку
- Если в точке объекты хранятся по правилу Single storage, то старая точка просто удаляется
### Logging

Логика работы **Backup Task** не должна напрямую завязываться на консоль или другие внешние компоненты. Чтобы поддержать возможность уведомлять пользователя о событиях внутри алгоритма, требуется реализовать интерфейс для логирования и вызывать его в нужных моментах. Например, писать что создается **Storage** или **Restore Point**. 

Задаваться способ логирования должен извне. Например, при создании **Backup Task**. В рамках системы ожидаются такие реализации логера:

- Консольный, который логирует информацию в консоль
- Файловый, который логирует в указанный файл

Для логирования сущностей стоит реализовать в самих сущностях методы, которые генерируют информативную строку, которая описывает сущность.

Для логера стоит поддержать возможность конфигурации - указать нужно ли делать префикс с таймкодом в начале строки.

### Восстановление

Целью создания резервных копий является предоставление возможности восстановиться из них. 

Требуется реализовать функционал, который бы позволял указать **Restore Point** и восстановить данные из него.
